# PassCrack
C/C++ cracker for Blake-hashed passwords using Rainbow Tables.

0.ΓΕΝΙΚΕΣ ΠΛΗΡΟΦΟΡΙΕΣ
-Η εφαρμογή αυτή είναι ένα πρόγραμμα C++ που επιτρέπει την ανακάλυψη ενός 
"μυστικού κωδικού πρόσβασης", με είσοδο τον κρυπτογραφικό κατακερματισμό (hash) του
κωδικού, κατασκευάζοντας και χρησιμοποιώντας έναν Rainbow Table, για να επιδείξει
την "Ισορροπία Χρόνου-Μνήμης" (Time-Memory Tradeoff) μιας τέτοιας επίθεσης, σε συνδυασμό με ένα πλήθος 
επιλογών παραμετροποίησης.




1.ΣΤΟΙΧΕΙΑ ΣΥΓΓΡΑΦΕΑ
-Τσαούσης Λεωνίδας
-Α.Μ.: 1115 2012 00184



2.ΠΕΡΙΕΧΟΜΕΝΑ ΚΑΤΑΛΟΓΟΥ PassCrack.tar
-README.txt.........................εγγραφο τεκμηρίωσης
-PassCrack..........................εκτελέσιμη εφαρμογή, τρέχουσα εδοση του προγράμματος
-main.cpp rainbowfuncts.cpp.........κώδικας της εφαρμογής
-blake.cpp blake.hpp................αρχεία υλοποίησης και διεπαφής αντίστοιχα για την BLAKE256, 
									μοναδική συνάρτηση κατακερματισμού που υποστηρίζεται.
-tablemodel.txt, chainmodel.txt.....αρχεία επίδειξης για την μορφή των αλυσίδων και του πίνακα.									
-makefile...........................αρχειο δημιουργίας με επιπλεόν δυνατότητες για:
	Ι.    δημιουρία εκτελέσιμου (με διαφορετικά ονόματα)
	ΙΙ.   διαγραφή εκτελέσιμου και αντικειμενικων αρχείων
	ΙΙΙ.  δημιουργία έκδοσης αποσφαλμάτωσης
	ΙV.   καταμέτρηση γραμμών κώδικα κ.α.
	    (εμπεριέχονται οδηγίες)



3.ΟΔΗΓΙΕΣ ΕΚΤΕΛΕΣΗΣ
Εκτέλεση απο το κέλυφος με τις εξής επιλογές:

	./PassCrack [-u] [-v] [-x]
				[-f <funct>]
				[-i <intable>] [-o <outtable>]
				[-t <tables> ]	
οπου:
-Ολες οι options είναι προαιρετικές (απεικονίζονται με αγκύλες στην παραπάνω μορφή).
-Μπορούν να δοθούν με οποιαδήποτε σειρά. Για τις επιλογές με παραμέτρους -f, -i, -o, -t 
	θα πρέπει να ακολουθούνται απο την αντίστοιχη παράμετρο.
-Συγκεκριμένα για κάθε option:
	-u (usage)		: εκτύπωση οδηγιών χρήσης / επιλογών χρήστη.
	-v (verbose)	: επιπλέον διαγνωστικά μυνήματα κατα την εκτέλεση.
					  -συνίσταται- (Χρησιμοποιήθηκε κατα τη διαδικασία της αποσφαλμάτωσης)
	-χ (explicit)	: ρητή δήλωση των παραμέτρων του Rainbow Table 'm' και 't'.
					  Προεπιλογή: m = 18 αλυσίδες ανα πίνακα, t = 1000 κόμβοι ανα αλυσίδα.
	-f (function) 	: χρήση της συνάρτησης κατακερματισμού <funct>.
					  Προεπιλογή: "blake", που είναι και ημόνη που υποστηρίζει η τρέχουσα έκδοση. 
	-t (table)		: δημιουργία <tables> συνολικά πινάκων.
					  Προεπιλογή: 1, αφού μόνο έναν πίνακα υποστηρίζει η τρέχουσα έκδοση. 
	-i (input)		: Εισαγωγή/εξαγωγή του πίνακα σε/απο αρχείο <intable>/<outtable> αντστοιχα.
	-o (output)		  (*)Το αρχείο εισόδου θα πρέπει να ακολουθεί συγκεκριμένη μορφή, όπως 
					  ακριβώς στο αρχείο επίδειξης tablemodel.txt
					  (*)Το αρχείο εξόδου δημιουργήται με συγκεκριμένη μορφή, όπως ακριβώς το
					  αρχείο επίδειξης tablemodel.txt
					  (*)Υποστηρίζεται επίσης απόλυτο/σχετικό μονοπάτι στην παράμετρο. 
	
	-s (save)		: Εξαγωγή ολόκληρων των αλυσίδων στο αρχείο <outchain> για λόγους επίδειξης.
					  (*)Το αρχείο εξόδου δημιουργήται με συγκεκριμένη μορφή, όπως ακριβώς το
					  αρχείο επίδειξης chainmodel.txt
					  (*)Υποστηρίζεται επίσης απόλυτο/σχετικό μονοπάτι στην παράμετρο. 
					  		



4.ΣΧΕΔΙΑΣΤΙΚΕΣ ΕΠΙΛΟΓΕΣ
-Η διαδικασίες του προγράμματος χωρίζονται σε δύο μέρη:
 	α) το OFFLINE PART οπου δημιουργήται, εισάγεται ο πίνακας και ρυθμίζονται οι 
 	   παραμετροι εκτέλεσης  
 	β) το ONLINE  PART οπου ξεκινώντας απο την είσοδο του hash, γίνονται οι κύκλοι 
 		αναζήτησης (Reduce–Lookup–Hash cycles)
 					
-Στα πλαίσια της άσκησης για την οποία αναπτύχθηκε το πρόγραμμα, το hash κωδικού άλλαζε 
μετα απο 20 δευτερόλεπτα. Γι'αυτό το λόγο, οταν ανανεωθεί το hash, με την αποστολή ενος
σήματος SIGTSTOP (Ctr+Z) απο το πληκτρολόγιο, κατα το online part (Reduce–Lookup–Hash cycles),
ξεκινάει η επανάληψη απο την αρχή με το νεό hash, αντί να επανεκκινήται το πρόγραμμα. 

-Ομοίως, για να ακυρωθεί η εκτέλεση απαιτείται εnα σήμα τερματισμού π.χ. SIGINT (Ctr+C).
Άρα τελικά ο βρόγχος Reduce-Lookup-Hash είναι ατέρμονως απο προεπλογή.

-Παρότι η τρέχουσα έκδοση περιλαμβάνει μόνο μια reduction function, η υποδομή είναι επαρκής
για την εύκολη εισαγωγή νέων, και άμεση χρήσητους με ελάχιστες αλλαγές. Βλ.: "password alphabet".
Η μοναδική Reduction Function που χρησιμοποιώ απο προεπιλογή αντιστοιχίζει hash σε κωδικούς ώς εξής:

	1) "Semi-ASCII"
	---------------
	Για τα πρώτα 6 byte του hash, αρχικά μηδενίζω το (msb) σημαντικότερ
	bit τους ωστε να ταιριάζουν με τον 7bit ASCII κώδικα, έπειτα αντιστοιχίζω: 

	00 ...... 2F | 30 ...... 39 | 3A ... 40 | 41 ...... 5A | 5B ... 60 | 60 ...... 7A | 7B ... 7F
	-------------+--------------+-----------+--------------+-----------+--------------+----------
	     !       | 0  1 .... 9  |    @      | A  B .... Z  |     !     |  a  b ... z  |     @


	

5.ΣΥΝΔΕΣΜΟΙ
-Για γενικές πληροφορίες περι Rainbow Tables: 				
										http://en.wikipedia.org/wiki/Rainbow_table

-Ενα αναλυτικό paper του Phillipe Oechslin για την θεωρία πίσω απο τα Time-Memory Tradeoffs:
										http://lasec.epfl.ch/~oechslin/publications/crypto03.pdf

-To paper του Martin Hellman που θεμελίωσε την ανάλυση αυτων των μεθόδων:
										http://www.cs.miami.edu/home/burt/learning/Csc609.122/doc/36.pdf 

-Για την επίσημη υλοποίηση της BLAKE που χρησιμοποιείται:
										https://131002.net/blake/#dl



6.ΜΕΛΛΟΝΤΙΚΕΣ ΕΠΕΚΤΑΣΕΙΣ
-υποστήριξη #redfuncts>1, #tables>1 για να μεγαλώσουν οι πιθανότητες σύμφωνα με το 
θεώρημα του Hellman (βλ. αντίστοιχο Συνδεσμο)
-Νεες redfun: digramms++ http://en.wikipedia.org/wiki/Digraph_%28orthography%29
-Παραλληλισμός για την δημιουργία του πίνακα, η πιο χρονοβόρα διαδικασία δεν αξιοποιέι
τις δυυνατότητες παραλληλισμού του συστήματος. Μια υλοποίηση με pthreads θα αύξανε 
κατακόρυφα την αποδοτικότητα του προγράμματος.











